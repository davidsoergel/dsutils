package com.davidsoergel.event;import com.davidsoergel.dsutils.HashMap2D;import com.davidsoergel.dsutils.Map2D;import org.apache.log4j.Logger;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.HashMap;import java.util.HashSet;import java.util.Iterator;import java.util.LinkedList;import java.util.Map;import java.util.Set;/* Rules:	1. Every event class has exactly one sub-event, e.g. a method that gets called on a listener	2. that method takes a single argument of the appropriate Event class	This is a singleton, but has a static facade.  Normally the static stuff is enough,	but it's still possible to instantiate and use several independent EventMediators.*/public class EventMediator	{// ------------------------------ FIELDS ------------------------------	private static Logger logger = Logger.getLogger(EventMediator.class);	private static EventMediator _instance = new EventMediator();	// **	// this uses concatenated strings as hash keys throughout, which is inefficient.	// also, assumes hashCodes are unique.	// too bad for now; fix later (needs HashMap2D)	// also need better variable names here	// HASHCODES SUCK	Map2D directListenerSets = new HashMap2D();  // actual listeners known directly here	Map2D allListenerSets = null; // new HashMap2D();  // all actual listeners, after dereferencing through relays (e.g., leaves)	Map2D relays = new HashMap2D();  // a relay rebroadcasts an event as if it were the source	Map allMethods = new HashMap();// -------------------------- STATIC METHODS --------------------------	public static EventMediator getInstance()		{		System.err.println("EventMediator instance");		return _instance;		}	public static void fire(EventObject event)		{		getInstance().fireEvent(event);		}	public void fireEvent(EventObject event)		{		EventSource source = (EventSource)event.getSource();		assert source != null;  // every event must have a source		Set allListeners = null;		try			{			allListeners = (Set) allListenerSets.get(event.getClass(), new Integer(source.persistentHashCode()));			}		catch (NullPointerException e)			{			allListenerSets = new HashMap2D();			}		if (allListeners == null)			{			//Class eventClass = event.getClass();			logger.debug("Calculating new listener set");			allListeners = getAllListeners(new HashSet(), source, event);			allListenerSets.put(event.getClass(), new Integer(source.persistentHashCode()), allListeners);			}		System.err.println(		        "Firing event: " + event.getClass() + " " + (source == null ? "null" : "" + source.persistentHashCode()) + " to "		        + allListeners.size()		        + " listeners");		// send it off		Object[] args = new Object[1];		args[0] = event;		Object listener;		Set theListenMethods;		Method theListenMethod;		for (Iterator i = allListeners.iterator(); i.hasNext();)			{			try				{				listener = i.next();				for (Iterator iterator = getListenMethods(listener.getClass(), event.getClass()).iterator(); iterator.hasNext();)					{					theListenMethod = (Method) iterator.next();					//if(theListenMethod != null) // could be a relay					//{					theListenMethod.invoke(listener, args);					//}					}				;				}			catch (EventMediatorException e)				{				e.printStackTrace();				}			catch (IllegalAccessException e)				{				e.printStackTrace();				}			catch (InvocationTargetException e)				{				e.getTargetException().printStackTrace();				}			}		}	private Set getAllListeners(Set doneRelays, EventSource source, EventObject event)		{		return getAllListeners(doneRelays, source, event.getClass());		}// -------------------------- OTHER METHODS --------------------------	public void addListenerAnyEvent(EventSource source, Object destination)		{		addListener(source, null, destination);		}	public void addListenerAnySource(Class eventtype, Object destination)		{		addListener(null, eventtype, destination);		}	// careful: registering something as a listener prevents it from being garbage-collected.	// should use soft references here.	// or, use a callback to unregister listeners when they're done	public void addListener(EventSource source, Class eventtype, Object destination)		{		//System.err.println("addListener");		logger.debug("addListener " + eventtype + " " + (source == null ? "null" : "" + source.persistentHashCode()));		logger.debug("addListener " + (source == null ? "null" : "" + source.persistentHashCode()) + " " + eventtype + " " + destination);		Set theListenerSet = (Set) directListenerSets.get(eventtype, (source != null) ? new Integer(source.persistentHashCode()) : null);		if (theListenerSet == null)			{			theListenerSet = new HashSet();			directListenerSets.put(eventtype,  (source != null) ? new Integer(source.persistentHashCode()) : null, theListenerSet);			}		theListenerSet.add(destination);		//allListenersSets.remove("" + eventCode + sourceCode);  // invalidate the previous network from this source		// ** need to invalidate any previous networks involving this node too, if it's a relay		// screw it, just invalidate everything for now		allListenerSets = null; // new HashMap2D();		}	// pass received events through to listeners	public void addRelay(Object relay, Class eventtype)		{		relays.put(relay, eventtype, Boolean.TRUE);		}	private Set getAllListeners(Set doneRelays, EventSource source, Class eventClass)		{		assert source != null;  // every event must have a source		Set allListeners = new HashSet();		logger.debug("getAllListeners " + eventClass + " " + source == null ? "null" : "" + source.persistentHashCode());		Set tmp;		// add all the object + type listeners		tmp = (Set) directListenerSets.get(eventClass, new Integer(source.persistentHashCode()));		if (tmp != null)			{			allListeners.addAll(tmp);			}		// add all of the object listeners		tmp = (Set) directListenerSets.get(null, new Integer(source.persistentHashCode()));		if (tmp != null)			{			allListeners.addAll(tmp);			}		// add all of the type listeners		tmp = (Set) directListenerSets.get(eventClass, null);		if (tmp != null)			{			allListeners.addAll(tmp);			}		// add all of the relayed listeners recursively, checking for loops		// (relays must also be registered as listeners already)		Object o;		for (Iterator i = new LinkedList(allListeners).iterator(); i.hasNext();)  // avoid ConcurrentModificationException			{			o = i.next();			//if(! (o instanceof EventSource)) { continue; }  // only EventSources can relay			if (relays.get(o, eventClass) != null && !doneRelays.contains(o))				{				assert (o instanceof EventSource);				doneRelays.add(o);				allListeners.addAll(getAllListeners(doneRelays, (EventSource)o, eventClass));				}			}		// add all listeners to superclasses of the EventObject class, recursively		// (there can't be any loops)		Class sc = eventClass.getSuperclass();		if (sc != null)			{			allListeners.addAll(getAllListeners(doneRelays, source, sc));			}		return allListeners;		}	private Set getListenMethods(Class listenerClass, Class eventClass) throws EventMediatorException		{		Set result = new HashSet();		Method m;		try			{			while (eventClass != null)				{				m = getListenMethod(listenerClass, eventClass);				if (m != null)					{					result.add(m);					}				eventClass = eventClass.getSuperclass();				}			}		catch (EventMediatorException e)			{			// no problem, we just broke the loop when we got high enough in the class heirarchy			// that the desired interface was not implemented			}		return result;		}	private Method getListenMethod(Class listenerClass, Class eventClass) throws EventMediatorException		{		Map theEventMethods = (Map) allMethods.get(eventClass);		if (theEventMethods == null)			{			theEventMethods = addEventClass(eventClass);			}		Method m = (Method) theEventMethods.get(listenerClass);		if (m == null)			{			Class[] args = {eventClass};			String handlerMethodName = null;			Class[] eventClassInnerClasses = eventClass.getDeclaredClasses();			for (int i = 0; i < eventClassInnerClasses.length; i++)				{				Class eventClassInnerClass = eventClassInnerClasses[i];				logger.debug("Checking inner class: " + eventClassInnerClass);				if (eventClassInnerClass.getName().endsWith("Listener"))					{					handlerMethodName = eventClassInnerClass.getMethods()[0].getName();					}				}			if (handlerMethodName == null)  // if we were anal, we could check here whether the arguments are right				{				throw new EventMediatorException("Event class " + eventClass.getName() + " does not contain a Listener"				                                 + " interface specifying a handler method");				}			try				{				m = listenerClass.getMethod(handlerMethodName, args);				}			catch (NoSuchMethodException x)				{				logger.debug("Method " + handlerMethodName + "(" + args + ")" + " not found in " + listenerClass);				m = null;  // OK, probably just a relay				}//			if(m == null && relays.get(o, eventClass) != null)//				{//				throw new EventMediatorException("Method " + handlerMethodName + "(" + args + ")" + " not found in class " + listenerClass);//				}			if (m != null)				{				theEventMethods.put(listenerClass, m);				}			}		return m;		}	public Map addEventClass(Class theClass)		{		Map theEventMethods = (Map) allMethods.get(theClass);		if (theEventMethods == null)			{			theEventMethods = new HashMap();			allMethods.put(theClass, theEventMethods);			}		return theEventMethods;		}	}